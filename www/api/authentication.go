package api

import (
	"bufio"
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"
	"log"
	"log/slog"
	"net/http"
	"os"
	"quotient/engine/config"
	"strings"
	"time"

	"github.com/go-ldap/ldap/v3"
	"github.com/gorilla/securecookie"
)

var (
	hashKey       []byte
	blockKey      []byte
	CookieEncoder *securecookie.SecureCookie
)

const COOKIENAME = "quotient"

// cookieSecure returns whether cookies should use the Secure flag (HTTPS only)
func cookieSecure() bool {
	return conf.SslSettings != (config.SslConfig{})
}

func init() {
	if _, err := os.Stat("config/COOKIEKEY"); err != nil {
		w, err := os.Create("config/COOKIEKEY")
		if err != nil {
			log.Fatalln(err)
		}
		defer w.Close()

		hashKey = securecookie.GenerateRandomKey(64)
		blockKey = securecookie.GenerateRandomKey(32)
		fmt.Fprintln(w, "# AUTOMATICALLY GENERATED BY INIT DO NOT TOUCH")
		fmt.Fprintf(w, "hashKey=%s\n", base64.StdEncoding.EncodeToString(hashKey))
		fmt.Fprintf(w, "blockKey=%s\n", base64.StdEncoding.EncodeToString(blockKey))
	} else {
		f, err := os.Open("config/COOKIEKEY")
		if err != nil {
			log.Fatalln(err)
		}
		defer f.Close()

		scanner := bufio.NewScanner(f)
		for scanner.Scan() {
			line := scanner.Text()
			if strings.Contains(line, "hashKey=") {
				decoded, err := base64.StdEncoding.DecodeString(strings.ReplaceAll(line, "hashKey=", ""))
				if err != nil {
					log.Fatalln(err)
				}
				hashKey = decoded
			} else if strings.Contains(line, "blockKey=") {
				decoded, err := base64.StdEncoding.DecodeString(strings.ReplaceAll(line, "blockKey=", ""))
				if err != nil {
					log.Fatalln(err)
				}
				blockKey = decoded
			}
		}
	}
	CookieEncoder = securecookie.New(hashKey, blockKey)
}

func Login(w http.ResponseWriter, r *http.Request) {
	type Form struct {
		Username string `json:"username"`
		Password string `json:"password"`
	}

	var form Form

	decoder := json.NewDecoder(r.Body)
	err := decoder.Decode(&form)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		slog.Error(err.Error())
		return
	}

	// check credentials
	auth, err := auth(form.Username, form.Password)
	if err != nil {
		w.WriteHeader(http.StatusUnauthorized)
		d, _ := json.Marshal(map[string]any{"error": "Incorrect username/password"})
		w.Write(d)
		slog.Info("Failed logon", "username", form.Username)
		return
	}

	cookie, err := CookieEncoder.Encode(COOKIENAME, auth)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		slog.Error(err.Error())
		return
	}

	http.SetCookie(w, &http.Cookie{
		Name:     COOKIENAME,
		Value:    cookie,
		MaxAge:   int((time.Hour * 24).Seconds()),
		HttpOnly: true,
		Secure:   cookieSecure(),
		Path:     "/",
	})

	slog.Info("Successful login", "username", form.Username)
}

func Logout(w http.ResponseWriter, r *http.Request) {
	http.SetCookie(w, &http.Cookie{
		Name:     COOKIENAME,
		Value:    "",
		MaxAge:   0,
		HttpOnly: true,
		Secure:   cookieSecure(),
		Path:     "/",
	})
	slog.Info("Successful logout", "username", r.Context().Value("username"))
}

// helper func
// should return value
func Authenticate(w http.ResponseWriter, r *http.Request) (string, []string) {
	token, err := r.Cookie(COOKIENAME)
	if err != nil {
		if err == http.ErrNoCookie {
			return "", nil
		}
		slog.Error(err.Error())
		return "", nil
	}

	var value map[string]any
	if err := CookieEncoder.Decode(COOKIENAME, token.Value, &value); err != nil {
		slog.Error(err.Error())
		return "", nil
	}

	username := value["username"].(string)

	// Extract auth source (default to "local" for backward compatibility)
	authSource := "local"
	if source, ok := value["authSource"].(string); ok {
		authSource = source
	}

	roles, err := findRolesByUsername(username, authSource)

	if err != nil {
		slog.Error(err.Error())
		return "", nil
	}

	// cookie refresh while still have value
	http.SetCookie(w, &http.Cookie{
		Name:     COOKIENAME,
		Value:    token.Value,
		MaxAge:   int((time.Hour * 24).Seconds()),
		HttpOnly: true,
		Secure:   cookieSecure(),
		Path:     "/",
	})

	return username, roles
}

func auth(username string, password string) (map[string]any, error) {
	for _, admin := range conf.Admin {
		if username == admin.Name && password == admin.Pw {
			return map[string]any{"username": username, "authSource": "local"}, nil
		}
	}
	for _, team := range conf.Team {
		if username == team.Name && password == team.Pw {
			return map[string]any{"username": username, "authSource": "local"}, nil
		}
	}
	for _, red := range conf.Red {
		if username == red.Name && password == red.Pw {
			return map[string]any{"username": username, "authSource": "local"}, nil
		}
	}
	for _, inject := range conf.Inject {
		if username == inject.Name && password == inject.Pw {
			return map[string]any{"username": username, "authSource": "local"}, nil
		}
	}

	// auth from other sources
	// if ldap configs are present, try to auth against ldap
	if conf.LdapSettings != (config.LdapAuthConfig{}) {
		conn, err := ldap.DialURL(conf.LdapSettings.LdapConnectUrl)
		if err != nil {
			return nil, err
		}
		defer conn.Close()

		// bind using the given username and password and searchbase from config
		err = conn.Bind(conf.LdapSettings.LdapBindDn, conf.LdapSettings.LdapBindPassword)
		if err != nil {
			return nil, err
		}

		searchRequest := ldap.NewSearchRequest(
			conf.LdapSettings.LdapSearchBaseDn,
			ldap.ScopeWholeSubtree, ldap.NeverDerefAliases, 0, 0, false,
			fmt.Sprintf("(&(objectClass=person)(sAMAccountName=%s))", ldap.EscapeFilter(username)),
			[]string{"dn"},
			nil,
		)

		sr, err := conn.Search(searchRequest)
		if err != nil {
			return nil, err
		}

		if len(sr.Entries) != 1 {
			return nil, errors.New("user does not exist or too many entries returned")
		}

		userDN := sr.Entries[0].DN

		err = conn.Bind(userDN, password)
		if err != nil {
			return nil, errors.New("invalid credentials")
		}

		// query for the user's roles
		roleSearchRequest := ldap.NewSearchRequest(
			conf.LdapSettings.LdapSearchBaseDn,
			ldap.ScopeWholeSubtree, ldap.NeverDerefAliases, 0, 0, false,
			fmt.Sprintf("(&(objectClass=person)(sAMAccountName=%s))", ldap.EscapeFilter(username)),
			[]string{"memberOf"},
			nil,
		)

		sr, err = conn.Search(roleSearchRequest)
		if err != nil {
			return nil, err
		}

		hasAuthorizedRole := false
		for _, entry := range sr.Entries {
			for _, memberOf := range entry.GetAttributeValues("memberOf") {
				if memberOf == conf.LdapSettings.LdapAdminGroupDn ||
					memberOf == conf.LdapSettings.LdapRedGroupDn ||
					memberOf == conf.LdapSettings.LdapTeamGroupDn {
					hasAuthorizedRole = true
					break
				}

				if memberOf == conf.LdapSettings.LdapInjectGroupDn {
					return map[string]any{"username": username, "authSource": "ldap"}, nil
				}
			}
			if hasAuthorizedRole {
				break
			}
		}

		if !hasAuthorizedRole {
			return nil, errors.New("LDAP user has no authorized roles")
		}

		return map[string]any{"username": username, "authSource": "ldap"}, nil
	}

	return nil, errors.New("no auth source matched credentials")
}

func findRolesByUsername(username string, authSource string) ([]string, error) {
	roles := make([]string, 0)

	// Only check OIDC users if auth source is OIDC
	if authSource == "oidc" {
		if userInfo, exists := GetOIDCUserInfo(username); exists {
			return userInfo.Roles, nil
		}
		// OIDC user not found in cache after server restart
		// User will need to re-authenticate
		return nil, errors.New("OIDC session expired - please login again")
	}

	// Check local users only if auth source is local
	if authSource == "local" {
		for _, admin := range conf.Admin {
			if username == admin.Name {
				roles = append(roles, "admin")
			}
		}
		for _, red := range conf.Red {
			if username == red.Name {
				roles = append(roles, "red")
			}
		}
		for _, team := range conf.Team {
			if username == team.Name {
				roles = append(roles, "team")
			}
		}
		for _, inject := range conf.Inject {
			if username == inject.Name {
				roles = append(roles, "inject")
			}
		}

		if len(roles) > 0 {
			return roles, nil
		}
		return nil, errors.New("local user has no roles")
	}

	// Check LDAP users only if auth source is LDAP
	if authSource == "ldap" && conf.LdapSettings != (config.LdapAuthConfig{}) {
		conn, err := ldap.DialURL(conf.LdapSettings.LdapConnectUrl)
		if err != nil {
			return nil, err
		}
		defer conn.Close()

		// bind using the given username and password and searchbase from config
		err = conn.Bind(conf.LdapSettings.LdapBindDn, conf.LdapSettings.LdapBindPassword)
		if err != nil {
			return nil, err
		}

		// query for the user's roles
		searchRequest := ldap.NewSearchRequest(
			conf.LdapSettings.LdapSearchBaseDn,
			ldap.ScopeWholeSubtree, ldap.NeverDerefAliases, 0, 0, false,
			fmt.Sprintf("(&(objectClass=person)(sAMAccountName=%s))", ldap.EscapeFilter(username)),
			[]string{"memberOf"},
			nil,
		)

		sr, err := conn.Search(searchRequest)
		if err != nil {
			return nil, err
		}

		for _, entry := range sr.Entries {
			for _, memberOf := range entry.GetAttributeValues("memberOf") {
				if memberOf == conf.LdapSettings.LdapAdminGroupDn {
					roles = append(roles, "admin")
				}

				if memberOf == conf.LdapSettings.LdapRedGroupDn {
					roles = append(roles, "red")
				}

				if memberOf == conf.LdapSettings.LdapTeamGroupDn {
					roles = append(roles, "team")
				}

				if memberOf == conf.LdapSettings.LdapInjectGroupDn {
					roles = append(roles, "inject")
				}
			}
		}

		if len(roles) > 0 {
			return roles, nil
		}
		return nil, errors.New("LDAP user has no authorized roles")
	}

	// Unknown auth source
	return nil, fmt.Errorf("unknown auth source: %s", authSource)
}
